if (crs(ortho) != crs(aoi)) {
ortho <- project(ortho, crs(aoi))
}
stopifnot(
crs(s2) == crs(aoi),
crs(s2dr3t) == crs(aoi),
crs(ortho) == crs(aoi)
)
# crop images to the aoi
s2dr3t <- crop(s2dr3t, vect(aoi))
s2 <- crop(s2, vect(aoi))
ortho <- crop(ortho,vect(aoi))
names(ortho) <- c("B02","B03","B04")
View(s2dr3t)
View(s2dr3t)
s2dr3t@pntr[["names"]]
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- s2dr3t
#ref_map <- s2
ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
SR_original <- SR_map
res(Sr_original)
terra::res(SR_original)
SR_original_tr <- SR_original %>% st_transform(31370)
SR_original_tr <- SR_original %>% st_warp(31370)
library(stars)
SR_original_tr <- SR_original %>% st_warp(31370)
SR_original_tr <- SR_original %>% st_transform(31370)
SR_original_tr <- project(SR_original, "EPSG:31370")
terra::res(SR_original_tr)
SR_map <- resample(SR_map, ref_map, method = "bilinear")
SR_map_tr <- project(SR_map, "EPSG:31370")
terra::res(SR_map_tr)
#| code-overflow: true
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- s2dr3t
#ref_map <- s2
ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
#SR_original <- SR_map
# ref_original <- ref_map
#SR_map <- resample(SR_map, ref_map, method = "bilinear")
ref_map <- resample(ref_map,SR_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
names(SR_map)
names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Metria image), and the second line does to opposite.
#ref_map <- ref_map[[names(SR_map)]]
SR_map <- SR_map[[names(ref_map)]]
stopifnot(
names(SR_map) == names(ref_map),
all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
SR_plot <- SR_map
#SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
if (global(is.na(SR_plot), "sum", na.rm = TRUE)[1,1] > 0 ||
global(is.na(ref_plot), "sum", na.rm = TRUE)[1,1] > 0) {
stop("Filter out NA values before proceeding")
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
rmse_vals <- c()
r2_vals   <- c()
R2_vals <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((SR_vals - mean(SR_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- (R2_vals, R2)
rmse_vals <- c()
r2_vals   <- c()
R2_vals <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((SR_vals - mean(SR_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
# Scatterplot the values and add the metrics
ggplot(plot_data, aes(x = ref, y = SR, color = Band)) +
geom_point(alpha = 0.3, size = 0.8) +
guides(color = guide_legend(override.aes = list(size = 3))) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
theme_minimal() +
scale_color_viridis_d(option = "B") +
labs(
title = "Super-resolution vs reference map",
x = "Reference map",
y = "Super-resolution map",
color = "Band"
) +
coord_fixed() +
annotate("text", x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5,
label = metrics_text, size = 4, color = "black")
1+1
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((SR_vals - mean(SR_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
# Scatterplot the values and add the metrics
ggplot(plot_data, aes(x = ref, y = SR, color = Band)) +
geom_point(alpha = 0.3, size = 0.8) +
guides(color = guide_legend(override.aes = list(size = 3))) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
theme_minimal() +
scale_color_viridis_d(option = "B") +
labs(
title = "Super-resolution vs reference map",
x = "Reference map",
y = "Super-resolution map",
color = "Band"
) +
coord_fixed() +
annotate("text", x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5,
label = metrics_text, size = 4, color = "black")
#| code-overflow: TRUE
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- s2dr3t
ref_map <- s2
#ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
SR_original <- SR_map
# ref_original <- ref_map
SR_map <- resample(SR_map, ref_map, method = "bilinear")
#ref_map <- resample(ref_map,SR_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
names(SR_map)
names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Metria image), and the second line does to opposite.
#ref_map <- ref_map[[names(SR_map)]]
SR_map <- SR_map[[names(ref_map)]]
stopifnot(
names(SR_map) == names(ref_map),
all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
SR_plot <- SR_map
#SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
# Fix if previous script caused an error:
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((SR_vals - mean(SR_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg   <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
# Scatterplot the values and add the metrics
ggplot(plot_data, aes(x = ref, y = SR, color = Band)) +
geom_point(alpha = 0.3, size = 0.8) +
guides(color = guide_legend(override.aes = list(size = 3))) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
theme_minimal() +
scale_color_viridis_d(option = "B") +
labs(
title = "Super-resolution vs reference map",
x = "Reference map",
y = "Super-resolution map",
color = "Band"
) +
coord_fixed() +
annotate("text", x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5,
label = metrics_text, size = 4, color = "black")
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
# Fix if previous script caused an error:
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((SR_vals - mean(SR_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
# Scatterplot the values and add the metrics
ggplot(plot_data, aes(x = ref, y = SR, color = Band)) +
geom_point(alpha = 0.3, size = 0.8) +
guides(color = guide_legend(override.aes = list(size = 3))) +
geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
theme_minimal() +
scale_color_viridis_d(option = "B") +
labs(
title = "Super-resolution vs reference map",
x = "Reference map",
y = "Super-resolution map",
color = "Band"
) +
coord_fixed() +
annotate("text", x = Inf, y = -Inf, hjust = 1.1, vjust = -0.5,
label = metrics_text, size = 4, color = "black")
getwd()
