approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
# Fix if previous script caused an error:
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((ref_vals - mean(ref_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg   <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
#| code-fold: TRUE
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- s2dr3t
ref_map <- s2
#ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
SR_original <- SR_map
# ref_original <- ref_map
SR_map <- resample(SR_map, ref_map, method = "bilinear")
#ref_map <- resample(ref_map,SR_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
names(SR_map)
names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Metria image), and the second line does to opposite.
#ref_map <- ref_map[[names(SR_map)]]
SR_map <- SR_map[[names(ref_map)]]
stopifnot(
names(SR_map) == names(ref_map),
all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
# Fix if previous script caused an error:
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((ref_vals - mean(ref_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
metrics_text
#| warning: FALSE
#| message: FALSE
library(terra)
library(ggplot2)
library(dplyr)
library(sf)
library(viridis)
library(SSIMmap)
library(INBOmd)
library(INBOtheme)
#| results: 'hide'
# upload AOI as geojson, shapefile or geopackage
aoi <- st_read("./source/Quantitative_Analysis_Webbekomsbroek/data/raw/test_site.shp")
# upload S2 scene
s2 <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/raw/S2L2A_T31UFS-1b90bf406-20230301_MS.tif")
if (crs(s2) != crs(aoi)) {
s2 <- project(s2, crs(aoi))
}
ortho <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/raw/Ortho_extent_WB_2023.tif")
ortho <- ortho * (10000 / 255)
if (crs(ortho) != crs(aoi)) {
ortho <- project(ortho, crs(aoi))
}
stopifnot(
crs(s2) == crs(aoi),
crs(ortho) == crs(aoi)
)
# crop images to the aoi
s2 <- crop(s2, vect(aoi))
ortho <- crop(ortho,vect(aoi))
metria_rgb <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/processed/Satlas_8_im_input/sr_mosaic.tif")
metria_scaled <- metria_rgb * (10000 / 255)
names(metria_scaled) <- c("B04", "B03", "B02")
metria_b8  <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/processed/Satlas_8_im_input/ps_b_8_wave.tif"); names(metria_b8)  <- "B08"
metria_b11 <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/processed/Satlas_8_im_input/ps_b_12_wave.tif"); names(metria_b11) <- "B11"
metria_b12 <- rast("./source/Quantitative_Analysis_Webbekomsbroek/data/processed/Satlas_8_im_input/ps_b_13_wave.tif"); names(metria_b12) <- "B12"
metria <- c(metria_scaled[["B02"]], metria_scaled[["B03"]], metria_scaled[["B04"]], metria_b8, metria_b11, metria_b12)
if (crs(metria) != crs(aoi)) {
metria <- project(metria, crs(aoi))
}
stopifnot(
crs(metria) == crs(aoi)
)
metria <- crop(metria, vect(aoi))
names(ortho) <- c("B02","B03","B04")
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#| code-fold: TRUE
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- metria
#ref_map <- s2
ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
#SR_original <- SR_map
# ref_original <- ref_map
#SR_map <- resample(SR_map, ref_map, method = "bilinear")
ref_map <- resample(ref_map,SR_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
names(SR_map)
names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Metria image), and the second line does to opposite.
#ref_map <- ref_map[[names(SR_map)]]
SR_map <- SR_map[[names(ref_map)]]
stopifnot(
names(SR_map) == names(ref_map),
all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((ref_vals - mean(ref_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg   <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
metrics_text
#| code-fold: TRUE
## Specify which two images (SR_map & ref_map) you want to evaluate
SR_map <- metria
ref_map <- s2
#ref_map <- ortho
## Re-scale the image with the higher resolution to match the resolution of the other. If your ref_map has the higher resolution, un-comment the row below and switch places of 'SR_map' and 'ref_map' in the line for resampling (down-scaling the resolution) of the SR_map/ref_map.
SR_original <- SR_map
# ref_original <- ref_map
SR_map <- resample(SR_map, ref_map, method = "bilinear")
#ref_map <- resample(ref_map,SR_map, method = "bilinear")
## Make sure the two maps contain the same bands. Check which bands your two maps have by un-commenting the two lines below
names(SR_map)
names(ref_map)
## If necessary, crop out the common bands from whichever file has the more bands by un-commenting one of the two lines below. The first line will extract the bands existing in SR_map from the ref_map (use this for evaluating the Metria image), and the second line does to opposite.
ref_map <- ref_map[[names(SR_map)]]
#SR_map <- SR_map[[names(ref_map)]]
stopifnot(
names(SR_map) == names(ref_map),
all(res(SR_map) == res(ref_map))
)
bands <- names(ref_map)
hist_match <- function(target_spat, ref_spat) {
matched_spat <- target_spat
for (i in 1:nlyr(target_spat)) {
target_vals <- values(target_spat[[i]], mat = FALSE)
ref_vals <- values(ref_spat[[i]], mat = FALSE)
target_vals <- target_vals[!is.na(target_vals)]
ref_vals <- ref_vals[!is.na(ref_vals)]
target_ecdf <- ecdf(target_vals)
ref_quant <- quantile(ref_vals, probs = seq(0, 1, length.out = 1000), na.rm = TRUE)
map_vals <- function(x) {
p <- target_ecdf(x)
approx(seq(0, 1, length.out = 1000), ref_quant, xout = p, rule = 2)$y
}
matched_vals <- map_vals(values(target_spat[[i]], mat = FALSE))
out_layer <- target_spat[[i]]
values(out_layer) <- matched_vals
matched_spat[[i]] <- out_layer
}
return(matched_spat)
}
SR_match <- hist_match(SR_map, ref_map)
#SR_plot <- SR_map
SR_plot <- SR_match
ref_plot <- ref_map
## Stack the super-resolution and ref maps
stack_names <- c(
paste0("SR_", bands),
paste0("ref_", bands)
)
stack <- c(SR_plot, ref_plot)
names(stack) <- stack_names
# Convert stacks to data frames for pixel comparison
df <- as.data.frame(stack, xy = TRUE, na.rm = TRUE)
# Prepare the super-resolution and sentinel-2 images for plotting
plot_data <- data.frame()
for (band in bands) {
SR_band <- paste0("SR_", band)
ref_band <- paste0("ref_", band)
if (!all(c(SR_band, ref_band) %in% colnames(df))) next
# Combine pixel values into a long-format dataframe
plot_data <- bind_rows(
plot_data,
data.frame(
SR = df[[SR_band]],
ref = df[[ref_band]],
Band = paste0(band)
)
)
}
# Fix if previous script caused an error:
SR_plot <- ifel(is.na(ref_plot), NA, SR_plot)
ref_plot <- ifel(is.na(SR_plot), NA, ref_plot)
# Fix if previous script caused an error:
rmse_vals <- c()
r2_vals   <- c()
R2_vals   <- c()
psnr_vals <- c()
ssim_vals <- c()
max_pixel <- 10000
for (band in bands) {
SR_vals  <- values(SR_plot[[band]], na.rm = TRUE)
ref_vals <- values(ref_plot[[band]], na.rm = TRUE)
# RMSE
rmse <- sqrt(mean((SR_vals - ref_vals)^2))
rmse_vals <- c(rmse_vals, rmse)
# r²
r2 <- cor(SR_vals, ref_vals)^2
r2_vals <- c(r2_vals, r2)
# R²
ss_res <- sum((SR_vals - ref_vals)^2)
ss_tot <- sum((ref_vals - mean(ref_vals))^2)
R2 <- 1 - (ss_res / ss_tot)
R2_vals <- c(R2_vals, R2)
# PSNR
psnr <- 20 * log10(max_pixel / rmse)
psnr_vals <- c(psnr_vals, psnr)
# --- SSIM (normalize to 0-1) ---
SR_norm  <- (SR_plot[[band]]) / max_pixel
ref_norm <- (ref_plot[[band]]) / max_pixel
ssim_out  <- capture.output(ssim_raster(SR_norm, ref_norm))
ssim_line <- grep("SSIM:", ssim_out, value = TRUE)[1]
ssim_val  <- as.numeric(sub(".*SSIM: ([0-9.]+).*", "\\1", ssim_line))
ssim_vals <- c(ssim_vals, ssim_val)
}
rmse_avg <- mean(rmse_vals)
r2_avg   <- mean(r2_vals)
R2_avg   <- mean(R2_vals)
psnr_avg <- mean(psnr_vals)
ssim_avg <- mean(ssim_vals)
# Annotation text
metrics_text <- paste(
paste0("RMSE = ", round(rmse_avg, 2)),
paste0("r² = ", round(r2_avg, 3)),
paste0("R² = ", round(R2_avg, 3)),
paste0("PSNR = ", round(psnr_avg, 2), " dB"),
paste0("SSIM = ", round(ssim_avg, 3)),
sep = "\n"
)
metrics_text
