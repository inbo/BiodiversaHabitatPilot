class_colors <- full_colors[present_classes]
ggplot() +
geom_stars(data = classified, aes(x = x, y = y)) +
scale_fill_manual(values = class_colors, name = "Inundation Class") +
geom_sf(data = AOI, fill = NA, color = "red", size = 0.7) +
coord_sf() +
facet_wrap(~ time, ncol = 3) +
labs(
title = "Inundation Frequency Classification",
x = "Longitude",
y = "Latitude"
) +
theme_minimal() +
theme(
legend.position = "right",
panel.border = element_rect(color = "grey40", fill = NA),
strip.text = element_text(face = "bold")
)
# MEAN - summarise values for site area
table_y_mean <-
obj_y_mean[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(Juss_cl, na.rm = TRUE)*100,
inundation_Wiw = mean(Wiw_cl, na.rm = TRUE)*100,
NDMI = mean(NDMI, na.rm=T), #Ranges from -1 to +1, where the lowest values indicate low vegetation water content, and the highest ones correspond to high water content
NDWI = mean(NDWI, na.rm=T), #Over 0.2: water. Below 0: non-water
NDPI = mean(NDPI, na.rm=T), # scores above a certain high value, e.g., larger than 0.75, indicates a pond area with good water quality
STR = mean(STR, na.rm=T), # Higher values, higher soil moisture content
B11 = mean(B11, na.rm=T)) # lower values, higher moisture.
#summarise min for sites (site mean at minimum wet situation)
table_y_min <-
obj_y_min[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(Juss_cl, na.rm = TRUE)*100,
inundation_Wiw = mean(Wiw_cl, na.rm = TRUE)*100,
NDMI = mean(NDMI, na.rm=T), #Ranges from -1 to +1, where the lowest values indicate low vegetation water content, and the highest ones correspond to high water content
NDWI = mean(NDWI, na.rm=T), #Over 0.2: water. Below 0: non-water
NDPI = mean(NDPI, na.rm=T), # scores above a certain high value, e.g., larger than 0.75, indicates a pond area with good water quality
STR = mean(STR, na.rm=T), # Higher values, higher soil moisture content
B11 = mean(B11, na.rm=T)) # lower values, higher moisture.
# for SWIR, wetness minimum is SWIR max value.
#summarise max for sites (site mean at minimum wet situation)
table_y_max <-
obj_y_max[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(Juss_cl, na.rm = TRUE)*100,
inundation_Wiw = mean(Wiw_cl, na.rm = TRUE)*100,
NDMI = mean(NDMI, na.rm=T), #Ranges from -1 to +1, where the lowest values indicate low vegetation water content, and the highest ones correspond to high water content
NDWI = mean(NDWI, na.rm=T), #Over 0.2: water. Below 0: non-water
NDPI = mean(NDPI, na.rm=T), # scores above a certain high value, e.g., larger than 0.75, indicates a pond area with good water quality
STR = mean(STR, na.rm=T), # Higher values, higher soil moisture content
B11 = mean(B11, na.rm=T)) # lower values, higher moisture.
# for SWIR, wetness maximum is SWIR min value.
# plot all yearly stats in one graph: Mean and shaded range between min-max
# STR
ggplot() +
#ylim(1,5)+ # adjust if needed
#geom_line(data= table_gf2w, aes(x = time - months(6), y = STR), color="grey") + # full time series to background?
geom_line(data= table_y_mean, aes(x = time, y = STR)) +
geom_point(data= table_y_mean, aes(x = time, y = STR)) +
geom_ribbon(aes(x = table_y_mean$time,
ymin = table_y_min$STR,
ymax = table_y_max$STR),fill="#1f9e89", alpha= 0.2)+
labs(title = "STR moisture mean and range (min, max)",
x = "Year",
y = "STR") +
theme_minimal() + theme(legend.position="none")
# NDMI
ggplot() +
#ylim(-0.1,0.5)+ # adjust if needed
#geom_line(data= table_gf2w, aes(x = time - months(6), y = NDMI), color="grey") + # full time series to background?
geom_line(data= table_y_mean, aes(x = time, y = NDMI)) +
geom_point(data= table_y_mean, aes(x = time, y = NDMI)) +
geom_ribbon(aes(x = table_y_mean$time,
ymin = table_y_min$NDMI,
ymax = table_y_max$NDMI),fill="#1f9e89", alpha= 0.2)+
labs(title = "NDMI moisture mean and range (min, max)",
x = "Year",
y = "NDMI") +
theme_minimal() + theme(legend.position="none")
# plot percentage of permanently and seasonally wet area.
# Jussila model
ggplot() +
ylim(0,100)+
geom_ribbon(aes(x = table_y_mean$time, # permanent
ymin = 0,
ymax = table_y_min$inundation),fill="#1f9e89", alpha= 0.6)+
geom_ribbon(aes(x = table_y_mean$time, # seasonal
ymin = table_y_min$inundation,
ymax = table_y_max$inundation),fill="#6ece58", alpha= 0.3)+  #Temporarily inundated
geom_ribbon(aes(x = table_y_mean$time, # never
ymin = table_y_max$inundation,
ymax = 100),fill="#fde725", alpha= 0.2)+ # Never inundated
labs(title = "Permanently and seasonally inundated area (Jussila model)",
x = "Year",
y = "Inundated area %") +
theme_minimal() + theme(legend.position="none") # + scale_x_date(date_breaks = "1 year")
# Lefebvre Wiw model
ggplot() +
ylim(0,100)+
geom_ribbon(aes(x = table_y_mean$time, # permanent
ymin = 0,
ymax = table_y_min$inundation_Wiw),fill="#1f9e89", alpha= 0.6)+
geom_ribbon(aes(x = table_y_mean$time, # seasonal
ymin = table_y_min$inundation_Wiw,
ymax = table_y_max$inundation_Wiw),fill="#6ece58", alpha= 0.3)+
geom_ribbon(aes(x = table_y_mean$time, # never
ymin = table_y_max$inundation_Wiw,
ymax = 100),fill="#fde725", alpha= 0.2)+
labs(title = "Permanently and seasonally inundated area (Lefebvre Wiw)",
x = "Year",
y = "Inundated area %") +
theme_minimal() + theme(legend.position="none") # + scale_x_date(date_breaks = "1 year")
# Assuming your object is named obj_classified and has a time dimension "t"
st <- obj_classified[AOI]
# 1. Extract time dimension
t_existing <- st_get_dimension_values(st, "t")
# 2. Create complete 5-day sequence
t_full <- seq(min(t_existing), max(t_existing), by = "5 days")
# 3. Find missing dates
t_missing <- setdiff(t_full, t_existing)
# 4. Proceed only if there are missing timestamps
if (length(t_missing) > 0) {
# --- Template Creation: Clean Reset of Time Dimension ---
# Take the first time slice, retaining all 4 dimensions (x, y, band, t)
template <- st[,,,1, drop = FALSE]
# Replace data with NA
template[[1]][] <- NA
# Define a dummy date placeholder, ensuring it's a POSIXct object
dummy_date <- min(t_existing) - as.difftime(1, units = "days")
dummy_date <- as.POSIXct(dummy_date)
#Reset the time dimension of the template using st_set_dimensions.
# This overwrites the existing dimension value and ensures the internal structure
# of the dimension object remains valid (e.g., handles "intervals" properties).
template <- st_set_dimensions(
template,
"t",
values = dummy_date,
# Also reset the point flag to FALSE for consistency if using intervals
point = FALSE
)
# --- Creating and Assigning Missing Layers ---
# Create a list of new layers for missing timestamps
missing_layers <- lapply(t_missing, function(tt) {
new_layer <- template
# Set the correct missing date 'tt' (overwriting the dummy_date)
# The crucial fix from previous steps: assign the result back
new_layer <- st_set_dimensions(new_layer, "t", values = tt)
return(new_layer)
})
# --- Combining Layers ---
# Prepare the full list of objects to combine
all_layers_to_combine <- c(list(st), missing_layers)
# Combine all layers along the time dimension
# This uses the c.stars method correctly by unpacking the list
st_full <- do.call(c, c(all_layers_to_combine, along = "t"))
# --- Final Sort (To Interleave the NA layers and resolve stacking) ---
# Sort the time dimension chronologically.
t_values_full <- st_get_dimension_values(st_full, "t")
sorted_indices <- order(t_values_full)
# Reorder the object data by subsetting with the sorted time indices
st_full <- st_full[,,, sorted_indices, drop = FALSE]
# Ensure the dimension values are also updated to the sorted order
st_full <- st_set_dimensions(
st_full,
"t",
values = sort(t_values_full)
)
} else {
st_full <- st
}
# Result
st_full
st_ones_alt <- st_full
st_ones_alt[[1]][!is.na(st_ones_alt[[1]])] <- 1
st_ones_alt[[1]][is.na(st_ones_alt[[1]])] <- NA # Ensure NA remains NA (as the first method does)
# Aggregate st_full by month, calculating the mean over each month.
# FUN = mean calculates the sum and divides by the number of non-NA dates in the month.
st_monthly_sum <- aggregate(
st_ones_alt,
by = "months",
FUN = sum,
na.rm = TRUE
)
ggplot() +
ggtitle("sum of valid pixels per month") +
geom_stars(data = st_monthly_sum) +
geom_sf(data = AOI, fill = NA, color = "red", linewidth = 1) +
facet_wrap(~time,ncol=12) +
theme_minimal() +
theme(axis.text = element_blank(),          # remove axis tick labels
axis.ticks = element_blank(),         # remove tick marks
)+
scale_fill_gradientn(
name = "X",
colors = c("white", "purple","darkblue"),
na.value = "gray",
#limits = c(0, 1)
)
# --- STEP 1: Extract Spatial Template ---
# The function needs the extent and CRS to turn the plain array data back into a SpatRaster.
# Slice the first time step and convert it to a SpatRaster to get the template metadata.
# template raster for extent and CRS
r_template <- rast(slice(obj_classified, "t", 1))
template_crs <- crs(r_template, proj=TRUE)
template_extent <- ext(r_template)
# function to process a single slice
focal_na_fill_modal <- function(x_slice) {
r_slice <- rast(t(x_slice))           # transpose first
ext(r_slice) <- template_extent
crs(r_slice) <- template_crs
r_focal <- focal(
r_slice,
w = 3,
fun = modal,
na.policy = "only",
na.rm = TRUE
)
as.matrix(r_focal) |> t()             # transpose back
}
# Apply across time
obj_focal_filled <- st_apply(obj_classified, MARGIN = "t", FUN = focal_na_fill_modal)
st_dimensions(obj_focal_filled)
st_dimensions(obj_classified)
obj_focal_filled <-
obj_focal_filled |>
st_crop(AOI)
plot(obj_classified)
plot(obj_focal_filled)
# Extract classes into a tibble
obj_focal_filled <- obj_focal_filled - 1 # convert 1-2 to 0-1
classified_df_filled <- as_tibble(obj_focal_filled[AOI])
# Add a month column
classified_df_filled <- classified_df_filled %>%
mutate(month = floor_date(t, "month"))
classified_df_filled_monthly_median <- classified_df_filled %>%
group_by(month, x, y) %>%      # group by pixel location + month
summarize(Class = median(X, na.rm = TRUE), .groups = "drop")
# Convert -Inf values to NA
classified_df_filled_monthly_median[classified_df_filled_monthly_median == -Inf] <- NA
# Convert back to stars
classified_filled_monthly_median <- st_as_stars(classified_df_filled_monthly_median, dims = c("x", "y", "month"))
plot(classified_filled_monthly_median)
# Existing data
existing_data <- classified_filled_monthly_median[[1]]
current_months <- st_get_dimension_values(classified_filled_monthly_median, "month")
# Create full monthly sequence
full_months <- seq(from = min(current_months), to = max(current_months), by = "month")
# Prepare new array with NAs for missing months
new_dims <- c(dim(classified_filled_monthly_median)[1:2], length(full_months))
new_array <- array(NA, dim = new_dims)
# Map existing data into correct positions
month_idx <- match(current_months, full_months)
new_array[,,month_idx] <- existing_data
# Start from the original dimensions object
dims <- st_dimensions(classified_filled_monthly_median)
# Update the month dimension's values
dims$month$values <- full_months
# Assign new array to the stars object
classified_filled_monthly_median <- st_as_stars(list(data = new_array))
# Attach updated dimensions
st_dimensions(classified_filled_monthly_median) <- dims
plot(classified_filled_monthly_median)
st_dimensions(classified_filled_monthly_median)
# Summarise per month
table_month <-
classified_filled_monthly_median[,,,] |>
as_tibble() |>
group_by(month) |>
summarize(inundation = mean(data, na.rm = TRUE)*100)
table_month_plotting <- table_month[!is.na(table_month$inundation),] # drop NAs for plotting
ggplot(table_month_plotting) + ## check the dates in table to plot a specific single year
aes(x = month, y = inundation) +
ylim(0,100) +
geom_line() + geom_point() +
labs(title = "Inundated area %",
x = "Date",
y = "Inundated area (%)") +
theme_minimal()
# extract time points per month
time_vals1m <- st_get_dimension_values(classified_filled_monthly_median, "month")
time_vals <- 1:dim(classified_filled_monthly_median)[3]  # or 1:length(time dimension)
obj_filled_1m <- st_apply(
classified_filled_monthly_median,
MARGIN = c("x", "y"),
FUN = function(ts) {
if (all(is.na(ts))) {
return(ts)
}
approx(
x = seq_along(ts),  # numeric indices of time points
y = ts,
xout = seq_along(ts),  # interpolate at same time points
method = "linear",
rule = 2
)$y
},
.fname = "month"
)
# fix the broken time dimension in output
obj_filled_1month <- st_set_dimensions(obj_filled_1m, "month", values = time_vals1m)
st_dimensions(classified_filled_monthly_median)
st_dimensions(obj_filled_1month)
ggplot() +
ggtitle("Per month mean class (Jussila)") +
geom_stars(data = obj_filled_1month["data"]) +
geom_sf(data = AOI, fill = NA, color = "red", linewidth = 1) +
facet_wrap(~month,ncol=12) +
theme_minimal() +
theme(axis.text = element_blank(),          # remove axis tick labels
axis.ticks = element_blank(),         # remove tick marks
) +
scale_fill_gradientn(
name = "Wetness",
colors = c("tan", "cyan", "blue"),
na.value = "gray",
limits = c(0, 1)
)
# Plot time series per month (gapfilled)
# first summarise for site area:
table_gf1m <- # Gapfilled table per month
obj_filled_1m[,,,] |>
as_tibble() |>
group_by(month) |>
summarize(inundation = mean(data, na.rm = TRUE)*100)
# New column: Flag gapfilled values
table_gf1m$gapfilled <- "monthly median"
table_gf1m$gapfilled[is.na(table_month$inundation)] <- "gapfilled"
table_gf1m$gapfilled <- as.factor(table_gf1m$gapfilled)
# time format to Date for plotting
table_gf1m$date <- as.Date(table_gf1m$month)
ggplot(table_gf1m) + #check the dates in table to plot a single year ([65:74,] -> 2018 in this case)
aes(x = date, y = inundation) + scale_x_date(date_labels = "%b %y") +
geom_line() + geom_point(aes(colour = gapfilled), size=2) +
scale_color_manual(values = c("gapfilled" = "red", "monthly median" = "black"), name=NULL)+
labs(title = "Inundation %",x = "Date",
y = "Inundated area (%)") +
ylim(0,100)+
theme_minimal()
# Using per month gapfilled stars object to calculate statistics
# aggregate stars into yearly layers
## Mean (for each pixel?)
obj_y_mean2 <- aggregate(obj_filled_1month, by = "year",
FUN=mean, na.rm=T)
## Min (for each pixel?)
obj_y_min2 <- aggregate(obj_filled_1month, by = "year",
FUN=min, na.rm=T) # returns Inf for NA areas
obj_y_min2[obj_y_min2 == Inf] <- NA # convert Inf back to NA
## Max (for each pixel?)
obj_y_max2 <- aggregate(obj_filled_1month, by = "year",
FUN=max, na.rm=T) # returns -Inf for NA areas
obj_y_max2[obj_y_max2 == -Inf] <- NA # convert -Inf back to NA
## Plot yearly raster maps
# Inundation (Jussila). Inundated % of time
plot(obj_y_mean2[1], col = viridis(100, option = "D", direction=-1),
breaks = seq(0, 1, length.out = 101), main = "Relative frequency of inundated pixels by Jussila model")
plot(obj_y_mean2[1]*12, col = viridis(100, option = "D", direction=-1),
breaks = seq(0, 12, length.out = 101), main = "Number of inundated months per year by Jussila model")
plot(obj_y_min2[1], col = viridis(100, option = "D", direction=-1),
breaks = seq(0, 1, length.out = 101))
plot(obj_y_max2[1], col = viridis(100, option = "D", direction=-1),
breaks = seq(0, 1, length.out = 101))
# MEAN - summarise values for site area
table_y_mean2 <-
obj_y_mean2[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(data, na.rm = TRUE)*100)
#summarise min for sites (site mean at minimum wet situation)
table_y_min2 <-
obj_y_min2[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(data, na.rm = TRUE)*100)
#summarise max for sites (site mean at minimum wet situation)
table_y_max2 <-
obj_y_max2[,,,] |>
as_tibble() |>
group_by(time) |>
summarize(inundation = mean(data, na.rm = TRUE)*100)
# plot percentage of permanently and seasonally wet area.
# Jussila model
ggplot() +
ylim(0,100)+
geom_ribbon(aes(x = table_y_mean2$time, # permanent
ymin = 0,
ymax = table_y_min2$inundation),fill="#1f9e89", alpha= 0.6)+
geom_ribbon(aes(x = table_y_mean2$time, # seasonal
ymin = table_y_min2$inundation,
ymax = table_y_max2$inundation),fill="#6ece58", alpha= 0.3)+  #Temporarily inundated
geom_ribbon(aes(x = table_y_mean2$time, # never
ymin = table_y_max2$inundation,
ymax = 100),fill="#fde725", alpha= 0.2)+ # Never inundated
labs(title = "Permanently and seasonally inundated area (Jussila model)",
x = "Year",
y = "Inundated area %") +
theme_minimal() + theme(legend.position="none") # + scale_x_date(date_breaks = "1 year")
# Extract the layer
x <- obj_y_mean2[1]
# Classify pixel values
vals <- x[[1]]
classified_vals <- ifelse(
is.na(vals), NA,
ifelse(vals == 0, "permanently dry",
ifelse(vals == 1, "permanently inundated",
"seasonally inundated"))
)
# Rebuild a stars object, preserving geometry
classified <- st_as_stars(classified_vals)
st_dimensions(classified) <- st_dimensions(x)
st_crs(classified) <- st_crs(x)
# Convert to factor (only with existing levels)
present_classes <- sort(unique(na.omit(as.vector(classified_vals))))
classified[[1]] <- factor(classified[[1]], levels = present_classes)
# Define full color scheme, but only use whatâ€™s needed
full_colors <- c(
"permanently dry" = "tan",
"seasonally inundated" = "lightblue",
"permanently inundated" = "blue4"
)
class_colors <- full_colors[present_classes]
ggplot() +
geom_stars(data = classified, aes(x = x, y = y)) +
scale_fill_manual(values = class_colors, name = "Inundation Class") +
geom_sf(data = AOI, fill = NA, color = "red", size = 0.7) +
coord_sf() +
facet_wrap(~ time, ncol = 3) +
labs(
title = "Inundation Frequency Classification",
x = "Longitude",
y = "Latitude"
) +
theme_minimal() +
theme(
legend.position = "right",
panel.border = element_rect(color = "grey40", fill = NA),
strip.text = element_text(face = "bold")
)
getwd()
getwd()
install.packages("here")
getwd()
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
cat("
<p>
<strong>Sebastiaan Verbesselt</strong><br>
Instituut voor Natuur- en Bosonderzoek<br>
<a href='https://orcid.org/0000-0003-0173-1123' target='_blank'>
<img src='../media/Orcid_icon.png' alt='ORCID'
style='width:18px; vertical-align:middle; margin-right:4px;'>
https://orcid.org/0000-0003-0173-1123
</a>
</p>
<p>
<strong>Tytti Jussila</strong><br>
Finnish Environment Institute<br>
<a href='https://orcid.org/0000-0003-4646-0152' target='_blank'>
<img src='../media/Orcid_icon.png' alt='ORCID'
style='width:18px; vertical-align:middle; margin-right:4px;'>
https://orcid.org/0000-0003-4646-0152
</a>
</p>
")
# Check automatically if you still need to install packages
list.of.packages <- c("tidyverse", "sf", "stars", "mapview", "lubridate", "dplyr", "rpart", "rpart.plot", "leaflet", "mapedit", "scales", "ggplot2", "rstudioapi","tidyr","zoo","np","kernlab","leafem","viridis","cubelyr","terra","signal","abind","INBOmd","INBOtheme")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load the packages
library(tidyverse)
library(sf)
library(stars)
library(mapview)
library(lubridate)
library(dplyr)
library(rpart)
library(rpart.plot)
library(leaflet)    # for interactive maps
library(leafem)
library(mapedit)    # for drawing polygons interactively
library(scales)
library(ggplot2)
library(rstudioapi)
library(tidyr)
library(zoo)
library(np)         # kernel regression
library(kernlab)    # Gaussian processes
library(viridis)
library(terra)
library(signal)
library(abind)
library(INBOmd)
library(INBOtheme)
if (requireNamespace("rstudioapi", quietly = TRUE)) {
folder <- rstudioapi::selectDirectory(caption = "Select a folder")
print(folder)
} else {
message("rstudioapi not available; please install it with install.packages('rstudioapi').")
}
if (is.null(folder)){
folder <- "./source/hydrology/data/"
}
wetlands <- st_read(paste0(folder,"raw/wetlands_kloosterbeemden.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
grasslands <- st_read(paste0(folder,"raw/grasslands_kloosterbeemden.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
polygons <- rbind(wetlands,grasslands)
plot(polygons["HAB1"])
getwd()
getwd()
getwd()
getwd()
