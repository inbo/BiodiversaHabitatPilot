library(openeo)
library(sf)
library(dplyr)
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
polygons <- st_read("./source/hydrology/data/raw/Demervallei.gpkg") %>% st_transform(crs = 4326)
getwd()
getwd()
library(openeo)
library(sf)
library(dplyr)
connection <- connect("<https://openeo.dataspace.copernicus.eu>")
login()
connection <- connect("<https://openeo.dataspace.copernicus.eu>")
login()
connection <- connect("<https://openeo.dataspace.copernicus.eu>")
login()
library(openeo)
library(sf)
library(dplyr)
connection <- connect("<https://openeo.dataspace.copernicus.eu>")
login()
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
polygons <- st_read("./source/data/raw/Demervallei.gpkg") %\>%
st_transform(crs = 4326)
polygons <- st_read("./source/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
getwd()
polygons <- st_read("/source/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
library(openeo)
library(sf)
library(dplyr)
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
polygons <- st_read("./source/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
library(openeo)
library(sf)
library(dplyr)
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
polygons <- st_read("./source/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
polygons <- st_read("./source/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
polygons <- st_read("./source/hydrology/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
library(openeo)
connect(host="https://openeo.dataspace.copernicus.eu/openeo/1.2/")
library(openeo)
library(sf)
library(dplyr)
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
connection <- connect("https://openeo.dataspace.copernicus.eu")
login()
polygons <- st_read("./source/hydrology/data/raw/Demervallei.gpkg") %>%
st_transform(crs = 4326)
bands <- c("B02", "B03", "B04", "B05", "B08", "B8A", "B11", "B12",
"SCL")
jobs <- list()
for (i in 1:nrow(polygons)) {
polygon <- polygons[i, ]
bbox <- st_bbox(polygon)
}
process <- processes()
spatial_extent <- list( west = bbox["xmin"], south = bbox["ymin"], east = bbox["xmax"], north = bbox["ymax"], crs = 4326 )
temporal_extent <- list("2025-10-06", "2025-10-14") # Get all Sentinel-2 bands between these two dates
collection <- process$load_collection( id = "SENTINEL2_L2A", spatial_extent = spatial_extent, temporal_extent = temporal_extent, bands = bands )
result <- process$save_result(data = collection, format = "NetCDF")
job <- create_job(graph = result, title = paste0("polygon_Demervallei_last_", i))
jobs[[i]] <- job cat("Job for polygon", i, "submitted./n") }
jobs[[i]] <- job
cat("Job for polygon", i, "submitted./n") }
jobs <- list()
for (i in 1:nrow(polygons)) {
polygon <- polygons[i, ]
bbox <- st_bbox(polygon)
# Get process graph builder
process <- processes()
# Define spatial extent
spatial_extent <- list(
west = bbox["xmin"],
south = bbox["ymin"],
east = bbox["xmax"],
north = bbox["ymax"],
crs = 4326
)
# Define temporal extent (all available years)
temporal_extent <- list("2025-10-06", "2025-10-14")
# Load Sentinel-2 L2A data using process graph builder
collection <- process$load_collection(
id = "SENTINEL2_L2A",
spatial_extent = spatial_extent,
temporal_extent = temporal_extent,
bands = bands
)
# Save the result using process$save_result
result <- process$save_result(data = collection, format = "NetCDF")
# Create the batch job
job <- create_job(graph = result, title = paste0("polygon_Demervallei_last_", i)) # polygon_Demervallei_i -> was from 2020-01-01 - 2024-12-31
# Submit the job
#job$send_job()
jobs[[i]] <- job
cat("Job for polygon", i, "submitted./n")
}
list_jobs() %>% names() -> job_names
for(i in 1:nrow(polygons)) { start_job(job_names[i]) }
list_jobs() %>% as_tibble() %>% View() # View the list of batch jobs on your OpenEO account
list_jobs() %>% as_tibble() %>% count(status) # See the status of your batch jobs
list_jobs() %>% as_tibble() -> jobs_df # create a dataframe of your batch jobs
#Ã¾id <- unlist(jobs_df[1,"id"]) #downname <- download_results(id, folder = "S2/") #print(downname)
list_jobs() %>% as_tibble() %>% View()
list_jobs() %>% as_tibble() %>% View() # View the list of batch jobs on your OpenEO account
for(i in 1:nrow(polygons)) {
id <- unlist(jobs_df[i,"id"])
name <- paste0("./source/hydrology/data/intermediate/", gsub(" ", "_", unlist(jobs_df[i, "title"])), ".nc")
print(name)
download_results(id, folder = "./source/hydrology/data/intermediate/") -> downname
file.rename(unlist(downname), name)
}
# Check automatically if you still need to install packages
list.of.packages <- c("tidyverse", "sf", "stars", "mapview", "lubridate", "dplyr", "rpart", "rpart.plot", "leaflet", "mapedit", "scales", "ggplot2", "rstudioapi","tidyr","zoo","np","kernlab","leafem","viridis","cubelyr","terra","signal","abind","INBOmd","INBOtheme")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load the packages
library(tidyverse)
library(sf)
library(stars)
library(mapview)
library(lubridate)
library(dplyr)
library(rpart)
library(rpart.plot)
library(leaflet)    # for interactive maps
library(leafem)
library(mapedit)    # for drawing polygons interactively
library(scales)
library(ggplot2)
library(rstudioapi)
library(tidyr)
library(zoo)
library(np)         # kernel regression
library(kernlab)    # Gaussian processes
library(viridis)
library(terra)
library(signal)
library(abind)
library(INBOmd)
library(INBOtheme)
cat("
<p>
<strong>Sebastiaan Verbesselt</strong><br>
Instituut voor Natuur- en Bosonderzoek<br>
<a href='https://orcid.org/0000-0003-0173-1123' target='_blank'>
<img src='../media/Orcid_icon.png' alt='ORCID'
style='width:18px; vertical-align:middle; margin-right:4px;'>
https://orcid.org/0000-0003-0173-1123
</a>
</p>
<p>
<strong>Tytti Jussila</strong><br>
Finnish Environment Institute<br>
<a href='https://orcid.org/0000-0003-4646-0152' target='_blank'>
<img src='../media/Orcid_icon.png' alt='ORCID'
style='width:18px; vertical-align:middle; margin-right:4px;'>
https://orcid.org/0000-0003-4646-0152
</a>
</p>
")
# Check automatically if you still need to install packages
list.of.packages <- c("tidyverse", "sf", "stars", "mapview", "lubridate", "dplyr", "rpart", "rpart.plot", "leaflet", "mapedit", "scales", "ggplot2", "rstudioapi","tidyr","zoo","np","kernlab","leafem","viridis","cubelyr","terra","signal","abind","INBOmd","INBOtheme")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
# Load the packages
library(tidyverse)
library(sf)
library(stars)
library(mapview)
library(lubridate)
library(dplyr)
library(rpart)
library(rpart.plot)
library(leaflet)    # for interactive maps
library(leafem)
library(mapedit)    # for drawing polygons interactively
library(scales)
library(ggplot2)
library(rstudioapi)
library(tidyr)
library(zoo)
library(np)         # kernel regression
library(kernlab)    # Gaussian processes
library(viridis)
library(terra)
library(signal)
library(abind)
library(INBOmd)
library(INBOtheme)
if (requireNamespace("rstudioapi", quietly = TRUE)) {
folder <- rstudioapi::selectDirectory(caption = "Select a folder")
print(folder)
} else {
message("rstudioapi not available; please install it with install.packages('rstudioapi').")
}
if (is.null(folder)){
folder <- "./source/hydrology/data/intermediate/"
}
polygons <- st_read(paste0(folder,"Webbekom_4testsites_demo.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
folder <- "./source/hydrology/data/"
polygons <- st_read(paste0(folder,"raw/Webbekom_4testsites_demo.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
polygons$ID <- c(1:5)
polygons$ID <- c(1:4)
plot(polygons["ID"])
polygons <- st_read(paste0(folder,"raw/Webbekom_4testsites_demo.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
polygons$ID <- c(1:5)
polygons <- st_read(paste0(folder,"raw/Webbekom_4testsites_demo.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
polygons$ID <- c(1:5)
plot(polygons["ID"])
polygons <- st_read(paste0(folder,"raw/Webbekom_5testsites_demo.gpkg")) |> st_transform(32631) # Transform to local crs system (WGS 84 / UTM zone 31N - EPSG:32631)
polygons$ID <- c(1:5)
plot(polygons["ID"])
AOI <- polygons %>% dplyr::filter(ID == 2)
plot(AOI["ID"])
# First: proxy loading (fast)
obj <- read_stars(paste0(folder,"intermediate/polygon_Demervallei_3.nc"), proxy = TRUE) # Region code: 1: Kloosterbeemden, 2: Schulensmeer, 3: Webbekomsbroek
obj2 <- read_stars(paste0(folder,"intermediate/polygon_Demervallei_new_3.nc"), proxy = TRUE)
obj3 <- read_stars(paste0(folder,"intermediate/polygon_Demervallei_last_3.nc"), proxy = TRUE)
# Ensure both have the same dimension names
names(st_dimensions(obj))
names(st_dimensions(obj2))
names(st_dimensions(obj3))
# Drop any extra dimension (e.g., a band dimension named "X" or similar)
obj  <- adrop(obj)
obj2 <- adrop(obj2)
obj3 <- adrop(obj3)
# Now combine along time
combined <- c(obj, obj2, along = "t")
combined <- c(combined, obj3, along = "t")
st_dimensions(obj)
st_dimensions(obj2)
st_dimensions(obj3)
st_dimensions(combined)
obj <- combined # Assign the combined datacube to the obj datacube (make a copy)
rm(obj2, obj3, combined) # Remove obj2, combined.
# Load now the data in memory:
obj <- st_as_stars(obj, along = "t")
wms_ortho_most_recent <- "https://geo.api.vlaanderen.be/OMWRGBMRVL/wms" # Most recent ortho image, winter, medium scale resolution.
wms_ortho <- "https://geo.api.vlaanderen.be/OMW/wms" # historical ortho images, winter, medium scale resolution.
wms_DEM <- "https://geo.api.vlaanderen.be/DHMV/wms" # Digital elevation model
# Load the decision tree model
load(paste0(folder,"/jussila_decisiontree.RData"))
# Load the decision tree model
load(paste0(folder,"raw/jussila_decisiontree.RData"))
# Visualize the decision tree structure
rpart.plot(tree_jussila, tweak = 1, extra = 0)
# Load the points
points <- st_read(paste0(folder,"/survey_points_HabitatPilot.gpkg"))
# Load the points
points <- st_read(paste0(folder,"raw/survey_points_HabitatPilot.gpkg"))
# Change multipoint to single point (if necessary)
points_single <- st_cast(points, "POINT")
points_single
# Select points that overlap with
points_single <- points_single |> st_transform(st_crs(AOI))
points_single <- points_single[st_intersects(points_single, AOI, sparse = FALSE), ]
points_single
# Ensure shapefile is in the right CRS (WGS84 lon/lat = EPSG:4326, since WCS expects that)
AOI_wgs84 <- st_transform(AOI, 4326)
points_wgs84 <- st_transform(points_single, 4326)
# Extract bounding box
bb <- st_bbox(AOI_wgs84)
# Compute centroid of bbox
center_lng <- (bb["xmin"] + bb["xmax"]) / 2
center_lat <- (bb["ymin"] + bb["ymax"]) / 2
map <- leaflet() %>%
addWMSTiles(
wms_ortho_most_recent,
layers = "Ortho",
options = WMSTileOptions(format = "image/png", transparent = FALSE)
) %>%
fitBounds(
lng1 = bb[["xmin"]],
lat1 = bb[["ymin"]],
lng2 = bb[["xmax"]],
lat2 = bb[["ymax"]]
)  %>%
addPolygons(data = AOI_wgs84, color = "red", weight = 2) %>%
addMarkers(
data = points_wgs84,
lng = st_coordinates(points_wgs84)[,1],
lat = st_coordinates(points_wgs84)[,2],
popup = points_wgs84$label
)
# Allow interactive drawing of polygons and save as trees_object
drawn <- mapedit::editMap(map)
# This returns an sf object with drawn features
trees_object <- drawn[["drawn"]]
trees_object <- st_make_valid(trees_object)
# Ensure shapefile is in the right CRS (WGS84 lon/lat = EPSG:4326, since WCS expects that)
AOI_wgs84 <- st_transform(AOI, 4326)
points_wgs84 <- st_transform(points_single, 4326)
# Extract bounding box
bb <- st_bbox(AOI_wgs84)
# Compute centroid of bbox
center_lng <- (bb["xmin"] + bb["xmax"]) / 2
center_lat <- (bb["ymin"] + bb["ymax"]) / 2
map <- leaflet() %>%
addWMSTiles(
wms_ortho_most_recent,
layers = "Ortho",
options = WMSTileOptions(format = "image/png", transparent = FALSE)
) %>%
fitBounds(
lng1 = bb[["xmin"]],
lat1 = bb[["ymin"]],
lng2 = bb[["xmax"]],
lat2 = bb[["ymax"]]
)  %>%
addPolygons(data = AOI_wgs84, color = "red", weight = 2) %>%
addMarkers(
data = points_wgs84,
lng = st_coordinates(points_wgs84)[,1],
lat = st_coordinates(points_wgs84)[,2],
popup = points_wgs84$label
)
# Allow interactive drawing of polygons and save as trees_object
drawn <- mapedit::editMap(map)
# This returns an sf object with drawn features
trees_object <- drawn[["drawn"]]
trees_object <- st_make_valid(trees_object)
# Inspect result
print(trees_object)
par(mfrow=c(1,2))
plot(st_geometry(AOI_wgs84),border='grey',axes=T,main="Habitat boundary")
for (i in 1:nrow(trees_object)){
AOI_wgs84 <- st_difference(AOI_wgs84,trees_object[i,])
}
plot(st_geometry(AOI_wgs84,border='grey',axes=T,main="Habitat boundary without trees"))
par(mfrow=c(1,1))
# Ensure shapefile is in the right CRS (WGS84 lon/lat = EPSG:4326, since WCS expects that)
AOI_wgs84 <- st_transform(AOI, 4326)
points_wgs84 <- st_transform(points_single, 4326)
# Extract bounding box
bb <- st_bbox(AOI_wgs84)
# Compute centroid of bbox
center_lng <- (bb["xmin"] + bb["xmax"]) / 2
center_lat <- (bb["ymin"] + bb["ymax"]) / 2
map <- leaflet() %>%
addWMSTiles(
wms_ortho_most_recent,
layers = "Ortho",
options = WMSTileOptions(format = "image/png", transparent = FALSE)
) %>%
fitBounds(
lng1 = bb[["xmin"]],
lat1 = bb[["ymin"]],
lng2 = bb[["xmax"]],
lat2 = bb[["ymax"]]
)  %>%
addPolygons(data = AOI_wgs84, color = "red", weight = 2) %>%
addMarkers(
data = points_wgs84,
lng = st_coordinates(points_wgs84)[,1],
lat = st_coordinates(points_wgs84)[,2],
popup = points_wgs84$label
)
# Allow interactive drawing of polygons and save as trees_object
drawn <- mapedit::editMap(map)
# Website with the public wms files for Flanders: https://wms.michelstuyts.be/?lang=nl
layer2024 <- "OMWRGB24VL"# select the winter image of 2024
layer2023 <- "OMWRGB23VL" # select the winter image of 2023
layer2022 <- "OMWRGB22VL"# select the winter image of 2022
layer2021 <- "OMWRGB21VL"# select the winter image of 2021
layer2020 <- "OMWRGB20VL"# select the winter image of 2020
map <- leaflet() %>%
addWMSTiles(
wms_ortho,
layers = layer2020,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB20VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2021,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB21VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2022,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB22VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2023,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB23VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2024,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB24VL"
) %>%
fitBounds(
lng1 = bb[["xmin"]],
lat1 = bb[["ymin"]],
lng2 = bb[["xmax"]],
lat2 = bb[["ymax"]]
)  %>%
addPolygons(data = AOI_wgs84, color = "red", weight = 2) %>%
addMarkers(
data = points_wgs84,
lng = st_coordinates(points_wgs84)[,1],
lat = st_coordinates(points_wgs84)[,2],
popup = points_wgs84$label
) %>%
addLayersControl(
baseGroups = c("OMWRGB20VL","OMWRGB21VL","OMWRGB22VL","OMWRGB23VL","OMWRGB24V"),
options = layersControlOptions(collapsed = FALSE)
)
map
# Website with the public wms files for Flanders: https://wms.michelstuyts.be/?lang=nl
layer2024 <- "OMWRGB24VL"# select the winter image of 2024
layer2023 <- "OMWRGB23VL" # select the winter image of 2023
layer2022 <- "OMWRGB22VL"# select the winter image of 2022
layer2021 <- "OMWRGB21VL"# select the winter image of 2021
layer2020 <- "OMWRGB20VL"# select the winter image of 2020
map <- leaflet() %>%
addWMSTiles(
wms_ortho,
layers = layer2020,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB20VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2021,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB21VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2022,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB22VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2023,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB23VL"
) %>%
addWMSTiles(
wms_ortho,
layers = layer2024,
options = WMSTileOptions(format = "image/png", transparent = FALSE),
group = "OMWRGB24VL"
) %>%
fitBounds(
lng1 = bb[["xmin"]],
lat1 = bb[["ymin"]],
lng2 = bb[["xmax"]],
lat2 = bb[["ymax"]]
)  %>%
addPolygons(data = AOI_wgs84, color = "red", weight = 2) %>%
addMarkers(
data = points_wgs84,
lng = st_coordinates(points_wgs84)[,1],
lat = st_coordinates(points_wgs84)[,2],
popup = points_wgs84$label
) %>%
addLayersControl(
baseGroups = c("OMWRGB20VL","OMWRGB21VL","OMWRGB22VL","OMWRGB23VL","OMWRGB24V"),
options = layersControlOptions(collapsed = FALSE)
)
map
dir <- "G:/Gedeelde drives/Team_BioDiv/5_Projecten/2024_Biodiversa_habitatpilot/WP2_3/EUGW/EUGW_data/type"
n2k <- "G:/Gedeelde drives/Team_BioDiv/5_Projecten/2024_Biodiversa_habitatpilot/WP2_3/EUGW/SBZSemois/Marais de la Haute-Semois.gpkg"
dir_out <- "G:/Gedeelde drives/Team_BioDiv/5_Projecten/2024_Biodiversa_habitatpilot/WP2_3/EUGW/stability&senkey/output"
min_count_for_nodes <- 100
min_count_for_links <- 100
# sad abandoned part of code
if (!dir.exists(dir_out)) dir.create(dir_out, recursive = TRUE)
# load libraries
source("knihovnik.R")
getwd()
